import React, { useState, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';
import TitleRow from '../TitleRow/TitleRow';
import HeaderRow from '../HeaderRow/HeaderRow';
import Midhalf from '../Midhalf/Midhalf';
import GridForm from '../GridForm/GridForm';
import MiscBlock from '../MiscBlock/MiscBlock';
import IOsComponent from '../IOsComponent/IOsComponent';
import { Container, Row, Col } from 'react-bootstrap';
import './MainContainer.scss';

const MainContainer = () => {
	const [dataSet, setDataSet] = useState([]);

	/**
	 * Generates a random RGBA color with a random alpha value.
	 *
	 * @function
	 * @returns {string} A string representing the RGBA color in the format 'rgba(r, g, b, a)'.
	 *                   The alpha (a) value is set to 0.7.
	 *
	 * @example
	 * const color = getRandomColor(); // Example output: 'rgba(123, 45, 67, 0.7)'
	 */
	const getRandomColor = () => {
		// Generate random values for red, green, and blue components
		let r = Math.floor(Math.random() * 256);
		let g = Math.floor(Math.random() * 256);
		let b = Math.floor(Math.random() * 256);

		// Return the rgba color string with the fixed alpha value
		return `rgba(${r}, ${g}, ${b}, 0.7)`;
	};

	/**
	 * Generates a random integer between the specified minimum and maximum values (inclusive).
	 *
	 * @function
	 * @param {number} min - The minimum value of the range (inclusive).
	 * @param {number} max - The maximum value of the range (inclusive).
	 * @returns {number} A random integer within the specified range.
	 *
	 * @example
	 * const randomNumber = getRandomNumber(1, 10); // Example output: 7
	 */
	const getRandomNumber = (min, max) => {
		return Math.floor(Math.random() * (max - min + 1)) + min;
	};

	/**
	 * Generates a position for a product based on a random selection between two predefined ranges.
	 *
	 * @function
	 * @returns {number} A randomly selected position for a product.
	 *                   The position is generated by choosing between two predefined ranges.
	 *                   The first range is [0, 18] and the second range is [40, 58].
	 *
	 * @example
	 * const productPosition = getPositionForProduct(); // Example output: 12
	 */
	const getPositionForProduct = () => {
		// Call getRandomNumber() function to get a random number in range
		let firstNum = getRandomNumber(0, 18);
		let secondNum = getRandomNumber(40, 58);

		// Generate a random number between 0 and 1
		let randomNum = Math.random();

		// Select the position based on the random number comparison
		let selectedNumber = randomNum < 0.5 ? firstNum : secondNum;

		// Return the selected position
		return selectedNumber;
	};

	/**
	 * Shuffles an array using the Fisher-Yates (Knuth) algorithm.
	 *
	 * @function
	 * @param {Array} products - The array to be shuffled.
	 * @returns {Array} A new array with elements randomly rearranged.
	 *
	 * @example
	 * const originalArray = [1, 2, 3, 4, 5];
	 * const shuffledArray = fisherYatesShuffled(originalArray);
	 * // Example output: [3, 1, 5, 2, 4]
	 */
	const fisherYatesshuffled = (products) => {
		// Create a copy of the input array
		const shuffledproducts = [...products];

		//Iterate over the array in reverse order
		for (let i = shuffledproducts.length - 1; i > 0; i--) {
			// Generate a random j index from the array's remaining unshuffled section.
			const j = Math.floor(Math.random() * (i + 1));

			// Swap the current element with j-th element
			[shuffledproducts[i], shuffledproducts[j]] = [
				shuffledproducts[j],
				shuffledproducts[i],
			];
		}

		// Return the shuffled array
		return shuffledproducts;
	};

	/**
	 * Checks if any adjacent elements in an array have the same 'product' property value.
	 *
	 * @function
	 * @param {Array} arr - The array containing elements to be checked for adjacency.
	 * @returns {boolean} Returns true if any adjacent elements have the same 'product' property value,
	 *                   otherwise returns false.
	 *
	 * @example
	 * const array1 = [{ product: 'A' }, { product: 'A' }, { product: 'B' }];
	 * const result1 = isAdjacentToEachOther(array1); // Example output: true
	 *
	 * const array2 = [{ product: 'X' }, { product: 'Y' }, { product: 'Z' }];
	 * const result2 = isAdjacentToEachOther(array2); // Example output: false
	 */
	const isAdjacentToEachOther = (arr) => {
		// Iterate through the array
		for (let i = 1; i < arr.length - 1; i++) {
			// Check if the current element and the next element has the same 'product' property value
			if (
				arr[i].product === arr[i - 1].product ||
				arr[i].product === arr[i + 1].product
			) {
				// Return "true" if have adjacent elements have the same 'product' property value
				return true;
			}
		}
		// Return "false" if no adjacent elements have the same 'product' property value
		return false;
	};

	/**
	 * Shuffles an array of products with specific constraints.
	 *
	 * @function
	 * @param {Array} flatArray - The array containing products to be shuffled.
	 * @returns {Array} A new array with products shuffled and positioned according to constraints.
	 *
	 * @example
	 * const originalProducts = [
	 *   { product: 'Core i1' },
	 *   { product: 'Core i2' },
	 *   // ... other products
	 *   { product: 'Core i4' },
	 *   { product: 'Core i5' },
	 * ];
	 * const shuffledProducts = shuffleProducts(originalProducts);
	 */
	const shuffleProducts = (flatArray) => {
		// Separate Core i5 from products
		let i5Product = flatArray.filter(
			(product) => product.product === 'Core i5'
		);

		// Separate Core i4 from products
		let i4Product = flatArray.filter(
			(product) => product.product === 'Core i4'
		);

		//Get position for the Core i4 and Core i5 product
		let positionForI4 = getPositionForProduct();
		let positionForI5 = getPositionForProduct();

		//Seperate other products from Core i5 and Core i4
		let otherProducts = flatArray.filter(
			(product) =>
				product.product !== 'Core i4' && product.product !== 'Core i5'
		);

		// Using fisherYatesshuffled function to shuffled
		// the data that don't contain 'Core i4' and 'Core i5' product
		let shuffleProducts = fisherYatesshuffled(otherProducts);

		// To check if any two adjacent elements in the array
		// have the same 'product' property value
		let isAdjacent = isAdjacentToEachOther(shuffleProducts);

		// To keep shuffle the data until the constraint is satisfied.
		while (isAdjacent) {
			shuffleProducts = fisherYatesshuffled(otherProducts);
			isAdjacent = isAdjacentToEachOther(shuffleProducts);
		}

		let resultArray = [...shuffleProducts];

		//To insert the 'Core i4' and 'Core i5' products into the
		//array of objects data at the specified position
		resultArray.splice(positionForI4, 0, i4Product[0]);
		resultArray.splice(positionForI5, 0, i5Product[0]);

		return resultArray;
	};

	/**
	 * Handles the click event for a diode box. Toggling the value of 'diode' key in the dataset.
	 *
	 * @function
	 * @param {string} id - The unique identifier of the element in the dataset.
	 * @returns {void}
	 *
	 * @example
	 * // DataSet contains objects with 'id' and 'diode' properties
	 * handleDiodeBoxClick(id);
	 */
	const handleDiodeBoxClick = (id) => {
		// To find the index of the element by the given id
		let index = dataSet.findIndex((data) => data.id === id);

		// To create a new array by shallow copy to avoid mutating the state directly
		let updatedDataSet = [...dataSet];

		//toggle the value of diode key, findIndex will return -1 if no element found
		if (index !== -1) {
			// Toggle the value of 'diode' key
			updatedDataSet[index].diode = !updatedDataSet[index].diode;
		}

		setDataSet(updatedDataSet);
	};

	/**
	 * Handles the click event for a mask box. Toggling the value of 'unmask' key of objects in the dataset
	 * for the specified product.
	 *
	 * @function
	 * @param {string} product - The product for which the 'unmask' key will be toggled.
	 * @returns {void}
	 *
	 * @example
	 * // DataSet contains objects with 'product' and 'unmask' properties
	 * handleMaskBoxClick(productName);
	 */
	const handleMaskBoxClick = (product) => {
		// Create a new array by shallow copy to avoid mutating the state directly
		let updatedDataSet = [...dataSet];

		// Toggle the value of 'unmask' key for the specified products
		updatedDataSet.forEach((data) => {
			if (data.product === product) {
				// Toggle the value of 'unmask' key
				data.unmask = !data.unmask;
			}
		});

		// Update the dataset state
		setDataSet(updatedDataSet);
	};

	//To fetch data when the component mounts
	useEffect(() => {
		const fetchData = async () => {
			try {
				// Fetch data from the '/dataset.json' endpoin
				let response = await fetch('/dataset.json');

				// Parse the JSON response
				let data = await response.json();

				// Create an array of repeated products based on the 'repeat' property
				let flatArray = data.reduce((acc, item) => {
					const productArray = [];

					// Generate product objects based on the 'repeat' property
					for (let i = 0; i < item.repeat; i++) {
						productArray.push({
							product: item.product,
							diode: false,
							unmask: false,
							id: uuidv4(),
							background: getRandomColor(),
						});
					}
					return acc.concat(productArray);
				}, []);

				//To get the shuffled data that meet constrain requirement.
				let shuffledArray = shuffleProducts(flatArray);

				// Set the shuffled data in the component state
				setDataSet(shuffledArray);
			
			} catch (error) {
				console.error('Error fetching data:', error);
			}
		};

		// Call the fetchData function when the component mounts
		fetchData();
	}, []);

	return (
		// Main container for the component
		<Container className="">
			<Row className="rows">
				 {/* Divide the talbe into 2 main columns. First, Left side column with a width of 11 columns */}
				<Col xs={11} className="columns left-side">

					{/* Component for the title row - First row of the table */}
					<TitleRow></TitleRow>

					{/* Component for the header row - Second row of the table */}
					<HeaderRow></HeaderRow>

					{/* There are 2 GridForm component, this is first GridForm component that contains the first half of the product information. */}
					<GridForm
						prop1="1"
						prop2="2"
						dataSet={dataSet}
						handleDiodeBoxClick={handleDiodeBoxClick}
						handleMaskBoxClick={handleMaskBoxClick}
					></GridForm>

					{/* Component for the mid-half section */}
					<Midhalf></Midhalf>

					{/* The second Gridform component that contains the second half of the product information. */}
					<GridForm
						prop1="3"
						prop2="4"
						dataSet={dataSet}
						handleDiodeBoxClick={handleDiodeBoxClick}
						handleMaskBoxClick={handleMaskBoxClick}
					></GridForm>

					{/* Component for the MISC Block The last row in the table*/}
					<MiscBlock></MiscBlock>
				</Col>

				{/* Right side column with a width of 1 column */}
				<Col xs={1} className="columns right-side">
					{/* Component for the IOs (Input/Output) section */}
					<IOsComponent></IOsComponent>
				</Col>
			</Row>
		</Container>
	);
};

export default MainContainer;
